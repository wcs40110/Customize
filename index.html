<script // IMMEDIATE CHECK FOR OPENTYPE.JS
  if (typeof opentype === 'undefined') {
    console.error("CRITICAL: opentype.js library did NOT load!");
    alert("CRITICAL: opentype.js did NOT load! Font features will not work. Check the browser console (Network tab) for issues loading 'opentype.min.js' from cdn.jsdelivr.net.");
    // Display error prominently on the page
    document.addEventListener('DOMContentLoaded', () => {
      const previewDiv = document.getElementById('svgPreview');
      if (previewDiv) {
        previewDiv.innerHTML = "<div style='color: red; font-weight: bold; padding: 10px;'>CRITICAL ERROR: opentype.js library failed to load. This is essential for font operations. Please check your browser's Network tab in the developer tools for errors related to 'opentype.min.js'. Ensure your internet connection is active and not blocking cdn.jsdelivr.net.</div>";
      }
      // Disable form
      const form = document.getElementById('customForm');
      if (form) {
        form.querySelectorAll('input, textarea, select, button').forEach(el => el.disabled = true);
      }
    });
  } else {
    console.log("SUCCESS: opentype.js library seems to be loaded.");
  }

  // Updated fontUrls to use relative paths
  // Ensure these filenames EXACTLY match the files in your repository (case-sensitive)
  const fontUrls = {
    "Satisfy": "./Satisfy-Regular.ttf",
    "Righteous": "./Righteous-Regular.ttf",
    "Grand Hotel": "./GrandHotel-Regular.ttf",
    "Short Stack": "./ShortStack-Regular.ttf",
    "Love Ya Like A Sister": "./LoveYaLikeASister-Regular.ttf",
    "Ribeye Marrow": "./RibeyeMarrow-Regular.ttf"
  };

  let loadedFont = null;
  let currentFontName = null;

  async function loadFont(fontName) {
    console.log(`[loadFont] Attempting to load font: ${fontName}`);
    if (typeof opentype === 'undefined') {
      const errorMsg = "[loadFont] CRITICAL: opentype.js is not defined. Cannot proceed.";
      console.error(errorMsg);
      document.getElementById('svgPreview').innerHTML = `<div style="color: red;">${errorMsg}</div>`;
      throw new Error("opentype.js is not defined inside loadFont.");
    }

    if (fontName === currentFontName && loadedFont) {
      console.log(`[loadFont] Using cached font: ${fontName}`);
      return;
    }

    const url = fontUrls[fontName];
    if (!url) {
      const errorMsg = `[loadFont] Font URL not found for: ${fontName}`;
      console.error(errorMsg);
      document.getElementById('svgPreview').innerHTML = `<div style="color: red;">${errorMsg}</div>`;
      throw new Error(errorMsg);
    }

    console.log(`[loadFont] Fetching URL: ${url}`);
    try {
      const res = await fetch(url);
      console.log(`[loadFont] Fetch response for ${fontName}: Status ${res.status}, OK: ${res.ok}`);
      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status} for ${url}. Ensure font file exists at this relative path and was deployed.`);
      }
      const fontBuffer = await res.arrayBuffer();
      console.log(`[loadFont] Font buffer received for ${fontName}, length: ${fontBuffer.byteLength} bytes.`);
      if (fontBuffer.byteLength < 100) { 
          console.warn(`[loadFont] WARNING: Font buffer for ${fontName} is very small (${fontBuffer.byteLength} bytes). Is the font file correct/complete?`);
      }
      loadedFont = opentype.parse(fontBuffer);
      console.log(`[loadFont] Font parsed successfully: ${fontName}`);
      currentFontName = fontName;
    } catch (error) {
      console.error(`[loadFont] Failed to load or parse font '${fontName}':`, error);
      document.getElementById('svgPreview').innerHTML = `<div style="color: red;">Error loading font '${fontName}': ${error.message}. Check console for details.</div>`;
      throw error; 
    }
  }

  function createSvg(text, font) {
    const fontSize = 80;
    const width = 600;
    const height = 150;
    
    let fontFamilyName = "Unknown";
    if (font && font.names && font.names.fontFamily && font.names.fontFamily.en) {
        fontFamilyName = font.names.fontFamily.en;
    } else if (font && font.familyName) { // Fallback if opentype.js structure is slightly different for some fonts
        fontFamilyName = font.familyName;
    }
    console.log(`[createSvg] Creating SVG for text "${text}" with font ${fontFamilyName}`);
    
    const path = font.getPath(text, 0, 0, fontSize); 
    const pathData = path.toPathData(2); 
    const svgContent = `
      <svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 -70 ${width} ${height}">
        <path d="${pathData}" fill="black"/>
      </svg>
    `;
    console.log("[createSvg] SVG markup generated.");
    return svgContent;
  }

  async function updatePreview() {
    console.log("[updatePreview] Called.");
    const text = document.getElementById('textInput').value.trim();
    const fontName = document.getElementById('fontSelector').value;
    const preview = document.getElementById('svgPreview');

    if (!text) {
      preview.innerHTML = "Enter text above to preview.";
      console.log("[updatePreview] No text, preview set to instruction.");
      return;
    }

    preview.innerHTML = `Loading font '${fontName}' and generating preview...`; 
    console.log(`[updatePreview] Text: "${text}", Font: "${fontName}"`);
    try {
      await loadFont(fontName);
      if (!loadedFont) { 
          console.error("[updatePreview] loadedFont is null after await loadFont(fontName).");
          throw new Error("Font could not be loaded or parsed successfully.");
      }
      const svgMarkup = createSvg(text, loadedFont);
      preview.innerHTML = svgMarkup;
      console.log("[updatePreview] SVG preview updated.");
    } catch (err) {
      console.error("[updatePreview] Error during preview update:", err);
      if (preview.innerHTML.includes("Loading font")) { 
        preview.innerHTML = `<div style="color: red;">Failed to update preview: ${err.message}. Check console.</div>`;
      }
    }
  }

  async function handleSubmit() {
    console.log("[handleSubmit] Form submitted.");
    const customer = document.getElementById('customerInput').value.trim();
    const desc = document.getElementById('descInput').value.trim();
    const location = document.getElementById('locationInput').value.trim();
    const text = document.getElementById('textInput').value.trim();
    const fontName = document.getElementById('fontSelector').value;

    if (!text) {
        alert("Enter some text to generate SVG.");
        console.log("[handleSubmit] No text to generate SVG.");
        return;
    }

    try {
        await loadFont(fontName); 
        if (!loaded.Font) { 
            console.error("[handleSubmit] loadedFont is null after await loadFont(fontName).");
            throw new Error("Font could not be loaded or parsed successfully for SVG generation.");
        }
        const svgMarkup = createSvg(text, loadedFont);

        const safeFileNameBase = [customer, desc, location]
            .map(s => s.replace(/\s+/g, "_").replace(/[^\w.-]/g, ''))
            .filter(s => s) 
            .join("_");
        
        const safeFileName = safeFileNameBase ? `${safeFileNameBase}_engraving.svg` : "custom_engraving.svg";

        const blob = new Blob([svgMarkup], { type: "image/svg+xml" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = safeFileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        console.log(`[handleSubmit] SVG downloaded as ${safeFileName}`);
        document.getElementById('popupOverlay').style.display = 'flex';
    } catch (err) {
        alert("Failed to generate SVG: " + err.message);
        console.error("[handleSubmit] SVG generation error:", err);
    }
  }

  // Event Listeners
  document.getElementById('textInput').addEventListener('input', updatePreview);
  document.getElementById('fontSelector').addEventListener('change', updatePreview);
  window.addEventListener('DOMContentLoaded', () => {
    console.log("[DOMContentLoaded] Page loaded, initial updatePreview call.");
    updatePreview(); 
  });

</script>
</body>
</html>
